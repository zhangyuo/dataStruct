#!/usr/bin/env python
# coding:utf-8
"""
# @Time     : 2020-02-11 10:26
# @Author   : Zhangyu
# @Email    : zhangycqupt@163.com
# @File     : tree_3.py
# @Software : PyCharm
# @Desc     :
"""

"""
树的定义：
高度：节点n到叶子节点的最长路径为节点n的高度，叶子结点的高度为零。树的高度为根节点到叶子结点的最长简单路径。
深度：根节点到节点n的路径为n的深度，根节点的深度为0。
度：节点的度是节点拥有的子树个数，二叉树的度小于等于二，因为它的最多只能有两个节点，也就是两个子数。

表达式树-用树结构表示算数运算符：
表达式中每一个运算符对应树结构的一个节点
运算符中的每一个运算对象在树中为该运算符的子树（从左向右）
运算对象中的单变量均为叶子节点

树的存储：
1、多重链表-存储树
存储单元   节点值   度   第一子节点   第二个子节点   ......   第N个子节点
5         书       4      7             13                    ...
7         第一章   2       ...          ...                 
13        第二章   3       ...          ...                    ...
......
  
"""
import math

def  print_tree(list):
    """
    给定一个列表，层序遍历，打印一个完全二叉树

    :param list:
    :return:
    """
    '''
    层数      层数取反(depth+1-i,depth表示总层数，此处为4，i表示层数)           据前面的空格数            间隔数        每层字数为
    1            4                                                              7                     0              1
    2            3                                                              3                     7              2
    3            2                                                              1                     3              4
    4            1                                                              0                     1              8
                                                                    (2**(depth-i)-1)      (2**(depth-i)-1)        (2**i）   

    层数和数据长度的关系是：
    1     1  
    2-3   2   
    4-7   3
    8-15  4       
    2**(i-1)<num<(2**i)-1
    
    树深度：n表示的是数据长度
    int(log2n) +1 或 math.ceil(log2n)
    '''
    index = 0
    depth = math.ceil(math.log(len(list), 2))   # 此处获取到的是此列表转换成二叉树的深度
    sep = '----'  # 此处表示数字的宽度,4个空格

    for i in range(depth):
        offset = 2**i  # 每层的数字数量1  2  4  8
        print(sep*(2**(depth-i-1)-1), end="")  # 此处取的是前面空格的长度
        line = list[index:index+offset]  # 提取每层的数量

        for j, x in enumerate(line):
            print("{:*^{}}".format(x, len(sep)), end="")  # 此处通过format来获取其偏移情况,第一个x表示其大括号中的内容，第二个表示偏移的程度,默认数字长度4个空格，不足4个补空格
            interval = 0 if i == 0 else 2**(depth-i)-1  # 此处获取到的是间隔数，当值大于1时，满足如此表达式
            if j < len(line)-1:  # 选择最后一个时不打印最后一个的后面的空格，及就是1,3,7后面的空格
                print(sep*interval, end="")
        index += offset
        print()


if __name__ == "__main__":
    tree_list = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13]
    print_tree(tree_list)

"""
格式：<模版字符串>.format(<逗号分割的参数>) 

<模版字符串>由一系列的槽组成，用来控制修改字符串中嵌入值出现的位置，其基本思想是将 format()方法的<逗号分隔的参数>中的参数按照序号关系替换到<模板字符串>的槽中。 
槽用大括号({})表示，如果大括号中没有序号，则按照出现顺序替换； 
如果大括号中指定了使用参数的序号，按照序号对应参数替换，参数从0开始编号。
 
例如："{}叫小兵，我在{}出生，我喜欢{}".format("我","1997-05-01","English") 
输出：“我叫小兵，我在1997-05-01出生，我喜欢English” 
例如："{2}叫小兵，我在{0}出生，我喜欢{1}".format("1997-05-01","English","我") 
输出：“我叫小兵，我在1997-05-01出生，我喜欢English” 

<模版字符串>的槽除了包括参数序号，还可以包括格式控制信息。此时，操的内部样式格式：{<参数序号>:<格式控制标记>} 
<格式控制标记>包括：
<填充>
<对齐>
<宽度>
,
<.精度>
<类型>
六个字段，可以组合使用。

<宽度>指当前槽的设定输出字符宽度，如果该槽对应的 format()参数长度比<宽度>设定值大，则使用参数实际长度。如果该值的实际位数小于指定宽度，则位数将被默认以空格字符补充。
<对齐>指参数在<宽度>内输出时的对齐方式，分别使用<、>和^三个符号表示左对齐、右对齐和居中对齐。
<填充>指<宽度>内除了参数外的字符采用什么方式表示，默认采用空格，可以通过<填充>更换。
, <格式控制标记>中逗号（，）用于显示数字的千位分隔符。如：“{0:-^20,}”.format(1234567890) ‘—1,234,567,890—-’ 
<.精度>表示两个含义，由小数点（.）开头。对于浮点数，精度表示小数部分输出的有效位数。对于字符串，精度表示输出的最大长度。

“{0:.2f}”.format(12345.67890) ‘12345.68’ 
“{0:H^20.3f}”.format(12345.67890) ‘HHHHH12345.679HHHHHH’ 
“{0:.4}”.format(“PYTHON”) ‘PYTH’ 

<类型>表示输出整数和浮点数类型的格式规则。
对于整数类型，输出格式包括 6 种： 
 b: 输出整数的二进制方式； 
 c: 输出整数对应的 Unicode 字符； 
 d: 输出整数的十进制方式； 
 o: 输出整数的八进制方式； 
 x: 输出整数的小写十六进制方式； 
 X: 输出整数的大写十六进制方式； 
例如： 
“{0:b},{0:c},{0:d},{0:o},{0:x},{0:X}”.format(425) ‘110101001,Ʃ,425,651,1a9,1A9’ 
对于浮点数类型，输出格式包括 4 种： 
 e: 输出浮点数对应的小写字母 e 的指数形式； 
 E: 输出浮点数对应的大写字母 E 的指数形式； 
 f: 输出浮点数的标准浮点形式； 
 %: 输出浮点数的百分形式。 
浮点数输出时尽量使用<.精度>表示小数部分的宽度，有助于更好控制输出格式。 
例如： 
“{0:e},{0:E},{0:f},{0:%}”.format(3.14) ‘3.140000e+00,3.140000E+00,3.140000,314.000000%’ 
“{0:.2e},{0:.2E},{0:.2f},{0:.2%}”.format(3.14) 
‘3.14e+00,3.14E+00,3.14,314.00%’
"""